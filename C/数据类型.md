# 数据类型

## 常量和变量

### 关键字

> C的关键字共有32个

- 数据类型关键字（12个）

  char,short,int,long,float,double

  unsigned,signed,struct,union,enum,void

- 控制语句关键字（12个）

  If,else,switch,case,default,

  for,do,while,break,continue,goto,return

- 存储类关键字（5个）

  auto,extern,register,static,const

- 其它关键字（3个）

  sizeof,typedef,volatile

### 数据类型

#### 作用

编译器预算对象（变量）分配的内存空间大小

#### 基本类型

- 整型 - int、short、long
- 字符型 - char
- 实型（浮点型）
  - 单精度实型 - float
  - 双精度实型 - double

#### 构造类型

- 数组类型
- 结构类型 - struct
- 联合类型 - union
- 枚举类型 - enum

#### 指针类型

- char *
- int *
- int **

### 常量

#### 定义

- 在程序运行过程中，其值不能被改变的量
- 常量一般出现在表达式或赋值语句中

#### 分类

- 整型常量
- 实型常量
- 字符常量
- 字符串常量

#### 定义常量的语法

##### 宏定义

```c
/*
1、# 开头的语句是预处理语句，不需要分号结束
2、定义一个宏定义的标识符MAX,它代表100
3、它是常量
4、宏定义以后的代码都可以使用MAX
5、在后面出现的MAX，预处理都会替换为100
*/
#define MAX 100   // 宏定义
```

##### const关键字定义

```c
/*
1、const是一个关键字，作用是修饰一个变量为只读
2、只读变量不允许修改
*/
const int c = 10;
```

### 变量

#### 变量

- 在程序运行过程中，其值可以改变
- 变量在使用前必须先定义，定义变量前必须有相应的数据类型

#### 标识符

- 标识符不能是关键字
- 标识符只能由数字、字母、下划线组成
- 第一个字符必须为字母或下划线
- 标识符中字母区分大小写

#### 变量特点

- 变量在编译时为其分配相应的内存空间

- 可以通过其名字和地址访问相应内存

- 定义变量时，必须有相应的类型

  ```c
  int a;
  ```

- 同一个{ }内部，不能重复定义同名变量

- 变量的初始化：定义变量的同时给变量赋值

  ```c
  int a = 10;
  ```

#### 声明和定义的区别

- 声明变量不需要建立存储空间

  ```c
  extern int a;
  /*没有存储空间就不能赋值，赋值会报错*/
  ```

- 定义变量需要建立存储空间

  ```c
  int a;   //定义
  ```

#### 有符号和无符号

```c
signed int a = 10;   //有符号
int a = 10;   //有符号
unsigned int a = 20;  //无符号
```

## 进制

### 二进制

#### 二进制转十进制

|  3   |  2   |  1   |  0   | 十进制结果 |
| :--: | :--: | :--: | :--: | :--------: |
|  1   |  0   |  1   |  0   |            |
| 2^3  |  0   | 2^1  |  0   |     10     |
|  1   |  1   |  1   |  1   |            |
| 2^3  | 2^2  | 2^1  | 2^0  |     15     |

#### 十进制转二进制

```
转化十进制10为二进制
10/2 = 5余数0
5/2 = 2余数1
2/2 = 1余数0
1/2 = 0余数1
最终的二进制是余数倒着连起来1010
转八进制、十六进制同理可得
```

### 八进制

#### 八进制转十进制

|   3   |   2   |  1   |  0   | 十进制结果 |
| :---: | :---: | :--: | :--: | :--------: |
|   1   |   0   |  1   |  0   |            |
|  8^3  |   0   | 8^1  |  0   |            |
|   3   |   2   |  1   |  1   |            |
| 3*8^3 | 2*8^2 | 8^1  | 8^0  |            |

### 十六进制

#### 十六进制转十进制

|   3    |   2    |  1   |  0   | 十进制结果 |
| :----: | :----: | :--: | :--: | :--------: |
|   1    |   0    |  1   |  0   |            |
|  16^3  |   0    | 16^1 |  0   |            |
|   3    |   2    |  1   |  1   |            |
| 3*16^3 | 2*16^2 | 16^1 | 16^0 |            |

### 进制互相转换

> 二进制三位对应八进制一位，从右边开始，左边不足三位部分补0

```
010 111 101 010 010 110
 2   7   5   2   2   6
```

> 二进制四位对应十六进制一位，从右边开始，左边不足四位部分补0

```
0101 1110 1010 1001 0101
  5    e    a    9    5 
```

> 八进制转换为十六进制的转换需要通过二进制转换

### C语言如何表示相应进制数

|   进制   |          代码写法           |
| :------: | :-------------------------: |
|  十进制  |      以正常数字1-9开头      |
|  八进制  |         以数字0开头         |
| 十六进制 |          以0x开头           |
|  二进制  | C语言不能直接书写二进制数字 |

```c
#include <stdio.h>

int main(){
    int a = 123; //十进制赋值
    int b = 0123; //八进制赋值
    int c = 0x123; //十六进制赋值
    printf("[10]a=%d\n",a);  //十进制输出
    printf("[8]a=%o\n",a);  //八进制输出
    printf("[16]a=%x\n",a);  //十六进制输出
    return 0;
}
```

## 计算机内存数值存储方式

### 原码

- 用户角度

- 原始的二进制

- 用户的数字分为正负数，涉及到符号位的存储

- 最高位为符号位

  - 0代表整数
  - 1代表负数

  ```
  +1 ： 0000 0001
  -1 ： 1000 0001
  +0 ： 0000 0000
  -0 ： 1000 0000
  ```

- 原码存储导致两个问题
  - 0有两种存储方式
  - 正数和负数相加，结果不正确（计算机只会加，不会减）

### 反码

- 为了算补码

- 求原码

- 正数的反码和原码是一样的

- 负数，在原码基础上，符号位不变，其他位取反

- 反码存储的问题：0仍然有两种存储方式

  ```
  +1 ： 0000 0001
  -1 ： 1000 0001   => 1111 1110
  +0 ： 0000 0000
  -0 ： 1000 0000   => 1111 1111
  ```

### 补码

> 计算机存储数字以补码方式存储（为了解决负数的存储）

- 正数的原码、反码、补码都一样

- 负数的反码+1，超过8位的最高位丢弃

- 补码符号位不动，其他位求反，最后整个数+1，得到原码

  ```
  +1 ： 0000 0001
  -1 ： 1111 1110   => 1111 1111
  +0 ： 0000 0000   
  -0 ： 1111 1111   => 1 0000 0000(最高位丢弃)
  ```

### 补码的意义

- 统一了零的编码
- 将符号位和其他位统一处理
- 将减法运算转变为加法运算
- 两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃

### 补码验证

- 二进制、八进制、十六进制，站在计算机角度，补码
- 十进制，站在用户角度，原码

## 数据类型的范围

> 站在10进制角度，原码
>
> 赋值或者运算，记得不要越界

### char :一字节

- 8位
- 有符号范围：
  - -128 ~ 127
  - -0 和-128的二进制一致
  - -128的原码和补码一样
- 无符号范围：
  - 0 ~ 255

## sizeof关键字

- sizeof不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节

- sizeof的返回值为size_t

- size_t类型在32位操作系统下是unsigned int，是一个无符号的整数

  ```c
  #include <stdio.h>
  
  int main(){
      int a = 10;
      printf("%u",sizeof(a))
      return 0;
  }
  ```

## 整型：int

### 整型变量的定义和输出

| 打印格式 |                含义                 |
| :------: | :---------------------------------: |
|    %d    |    输出一个有符号的10进制int类型    |
|    %o    |         输出8进制的int类型          |
|    %x    | 输出16进制的int类型，字母以小写输出 |
|    %X    | 输出16进制的int类型，字母以大写输出 |
|    %u    |      输出一个无符号的10进制数       |
|   %hd    |            输出short类型            |
|    %l    |            输出long类型             |
|   %ll    |          输出long long类型          |
|   %hu    |       输出unsigned short类型        |
|   %lu    |        输出unsigned long类型        |
|   %llu   |     输出unsigned long long类型      |

```c
#include <stdio.h>

int main(){
    /*
    整型变量的定义，10进制，8进制，16进制
    */
    int a;
    printf("请输入a:");
    scanf("%d",&a);
    int b = 0567;
    int c = 0xabc;
    printf("a=%d\n",a);
    printf("8进制：b=%o\n",b);
    printf("10进制：b=%d\n",b);
    printf("16进制：c=%x\n");
    printf("16进制：c=%X\n");
    printf("10进制：c=%d\n",c);
    return 0;
}
```

### 整型变量的输入

```c
#include <stdio.h>
/*
scanf()接受用户的输入，并赋值给指定变量
*/
int main(){
    int a;
    printf("请输入a： ");
    scanf("%d",a);
    printf("a = %d\n",a)
    return 0;
}
```

### short、int、long、long long

| 数据类型  |                          占用空间                          |
| :-------: | :--------------------------------------------------------: |
|   char    |                           1字节                            |
|   short   |                           2字节                            |
|    int    |                           4字节                            |
|   long    | Windows：4字节，Linux（32位）：4字节，Linux（64位）：8字节 |
| long long |                           8字节                            |

- 需要注意的是，整型数据在内存中占的字节数与所选择的操作系统有关。
- 当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化
- 当一个大的数据类型赋值给一个小的数据类型，那么就可能丢失高位

## 字符型：char



