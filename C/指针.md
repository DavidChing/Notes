# 指针

## 指针基础

### 指针的定义和操作

- 硬盘中运行程序，加载到内存
- 运行着的程序叫进程
- 定义变量，分配内存
- 内存，以1个字节为单位分配
  - int有4个地址，用的是首地址
  - char有1个地址
- &a取的地址是变量首个字节的地址
- 每个字节的内存都有标号，这个标号就是地址，也叫指针
- 地址需要存储，32位编译器用32位(4字节)存放地址，64位编译器用64位(8字节)存放地址
- 内存分配标号 -> 编码
- 根据地址找到相应的内存 -> 寻址
- 指针是内存单元的编号，指针变量是存放地址的变量

```c
#include <stdio.h>

int main(){
    /*
    1、指针也是一种数据类型
    2、指针指向谁，就把谁的地址赋值给指针
	3、直接操作指针变量本身没有意义
	4、需要操作*p，操作指针所指向的内存
    */
    int *p;  //p是一个变量，类型是int *，定义指针变量
    /*
      *p中的*有两层含义
      1、定义变量时，*代表是类型，它是指针类型int *
      2、使用变量时，*代表操作指针所指向的内存
    */
    int a = 10;
    p = &a;   //p保存了a的地址
    printf("%p,%d\n",p,a);  // 地址，10
	*p = 100;   //*p指向变量a，操作*p等于操作a变量，操作指针所指向的内存
    p[0] = 250; //*p等价于*(p+0),也等价于p[0],操作的是指针所指向的内存
    printf("%d,%d\n",*p,a);  // 100，100
    return 0;
}
```

### 野指针

```c
#include <stdio.h>

int main(){
    /*
    1、只有定义后的变量的地址才是合法的地址
	2、野指针就是保存没有意义地址的指针变量
	3、操作野指针变量本身不会有任何问题
	4、操作野指针所指向的内存会导致段错误
    */
    int *p;
	*p = 100;  // 非法操作内存
	printf("%d\n",*p);
    return 0;
}
```

### 空指针

```c
#include <stdio.h>

int main(){
    /*
    1、空指针就是给指针变量赋值为NULL
	2、NULL就是数字0
    */
   int *p = NULL;  //空指针
   int a = 11;
   p = &a;
   if(p != NULL){  //预防操作野指针
	   *p = 100;
   }
   return 0;
}
```

### 指针大小

```c
#include <stdio.h>

int main(){
    /*
    1、32位编译器用32位大小（4字节）保存地址
    2、64位编译器用64位大小（8字节）保存地址
    */
	int a = sizeof(int *);
	int b = sizeof(char *);
	printf("a = %d,b = %d\n",a,b); // a = 8,b = 8
	return 0;
}
```

### 多级指针

```c
#include <stdio.h>

int main(){
    /*
	1、定义一个合适类型的变量保存另一个变量的地址
    2、在需要保存地址的变量类型基础上加一个*
    */
	int a = 10;
	int *p = &a;
	int **q = &p;
	int ***t = &q;
	int ****m = &t;
	/*
	*m  -> t
	**m -> q
	***m -> p
	****m -> a
	*/
	return 0;
}
```

### 万能指针

```c
#include <stdio.h>

int main(){
    /*
	1、不可以定义void类型的普通变量
	2、可以定义void *类型的指针变量，也叫做万能指针
	3、void *类型的变量，可以指向任何类型的变量
	4、使用指针所指向的内存时，最好转换为它本身的指针类型
	5、指针变量的类型要和指针指向的变量的数据类型一致
	6、不做类型转换，无法确定指针步长
    */
	void *p = NULL;
	int a = 10;
	p = &a;
	*((int *)p) = 222;  //转换为指向的变量的数据类型
	printf("%d\n",*(int *)p);  //转换为指向的变量的数据类型
	return 0;
}
```

### 指针步长

```c
#include <stdio.h>

int main(){
    /*
	1、指针的加法，不是传统的加法
	2、步长由指针指向的数据类型决定
    */
	int a;
	int *p = &a;
	printf("p: %d, p+1: %d\n",p,p+1); //p: 6422028, p+1: 6422032	
	
	char b;
	char *q = &b;
	printf("q: %d, q+1: %d\n",q,q+1); //q: 6422027, q+1: 6422028
	return 0;
}
```

### const修饰的指针变量

```c
#include <stdio.h>

int main(){
    /*
	1、指针变量
	2、指针所指向的空间
	3、const修饰*，代表指针所指向的内存空间是只读的
	4、const修饰指针变量，代表指针变量的值为只读
    */
	int a = 10;
	int *p1 = &a;
	*p1 = 100; // 等价于操作a，*p1操作指针所指向的空间
	p1 = NULL;  //操作指针变量
	
	const int *p2 = &a;  //只读，不能修改指针指向的变量
	*p2 = 100; //出错
	p2 = NULL; //ok   指针变量可以修改
	int const *p3 = &a;  //只读，不能修改指针指向的变量，指针变量可以修改
    
	int * const p4 = &a; //指针变量只读，指针指向的变量可以修改
	*p4 = 1000;  //ok
	p4 = NULL;  //出错
	
	const int * const p5 = &a; //变量只读，指向的变量也只读
	return 0;
}
```

## 指针和数组